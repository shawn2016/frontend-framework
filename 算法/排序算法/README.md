# 排序

排序是将所有无需的序列标称有序的序列
  * 将列表元素从无序变成有序
  * 排列标中的元素，使表中元素满足按关键字递增或递减
  自然语言描述：

   输入n个记录 R1、R2....Rn 对应的关键字为K1、K2....Kn
   输出R1'、R2'....Rn' 对应的关键字为K1<=K2<=....Kn 
  
**排序算法稳定性**

   若待排序表中有两个元素Ri和Rj,对应的关键字是ki=kj ,且在排序前，Ri在Rj的前面，使用某个排序算法后，Ri仍然在Rj的前面，就成这个算法是稳定的，否则是不稳定的。
   
   待排序的记录序列中，存在多个具有相同的关键字的记录，经过排序，这些记录的相对次序保持不变。
   
   算法稳定性是衡量算法的性质，而不是衡量一个算法的优劣
 
```
  如排序 [1,4,7,3,2,1] 初始存在相同的带排序序列 第一个位置为a,最后一个位置的1为b,在排序完成后，可能存在的排序序列
 l1=  [a,b,2,3,4,7] 或者 l2= [b,a,2,3,4,5] 而l2排序后，b相对于a的初始位置发生了变化，因此是不稳定排序
  
```
## 内部排序和外部排序

 * 内部排序：指在排序期间元素全部存放在内存中的排序
 * 外部排序：指在排序期间元素无法全部同时存放在内容中，必须在排序过程中根据要求不断的内、外存之间进行移动
 


## 排序算法

 ### 插入排序
  **每一步将一个待排序的元素，按其排序码的大小，插入到前面已经排好序的一组元素的适当位置上去，直到元素全部插入为止。**
  
  

时间复杂度 | 空间复杂度 | 稳定性
---|--- | ---
最好情况o(n) 最坏情况o(n~2) | o(1) | 稳定 

  * 直接插入排序
   直接插入插排的基本思想是：
  ```
      当插入第i(i >= 1)时，前面的V[0]，V[1]，……，V[i-1]已经排好序。
      用V[I]的排序码与V[i-1]，V[i-2]，…的排序码顺序进行比较，
      找到插入位置即将V[i]插入，
      原来位置上的元素向后顺移。
  ```
   
  * 折半插入排序
   二分法的思想，在一个有序的序列中，找到新元素在该序列中的位置，然后插入
   ```
    1.当插入第i个元素时候,首先查找到带排序序列的最高位置元素high和最低位置low
    2.对比当前元素和(low+high)/2时候的元素大小，如果当前元素是大于中间元素，则当前元素排序位置应该在中间元素后面，将low = (low+hign)/2
    3.反复进行2操作，直到找到合适位置，使得当前low>high,

   ``` 
  * 希尔插入排序
   增量式排序算法
```
基本思想：
先将排序表分割成d个形如l[i,i+d,i+2d...i+kd]的特殊子序列，分别进行直接插入排序，当整个表中的元素已呈基本有序时候，在对全体标记记录进行一次直接插入的排序
选择步长d:d1=n/2 d(i+1) = di/2
```


 ### 交换排序
  * 冒泡排序
     
```
 将序列表中的值，从后往前两两比较相邻的元素的值
 将整个待排序的记录序列划分成有序区和无序区，初始状态有序区为空，无序区包括所有待排序的记录
 对无序区从前向后依次将相邻记录的关键字进行比较，若逆序将其交换，从而使得关键字值小的记录向 上”飘浮”（左移），关键字值大的记录好像石块，向下“堕落”（右移）。 每经过一趟冒泡排序，都使无序区中关键字值最大的记录进入有序区，对于由n个记录组成的记录序列，最多经过n-1趟冒泡排序，就可以将这n个记录重新按关键字顺序排列。
 
```

  * 快速排序
  
```

在待排序的列表中l[1...n]中任取一个元素pivot作为基准，通过一趟排序将待排序表划分为具有如下特点的两部分l[1..k-1]povit l[k-1..n]
基本思想：初始化标记low为划分部分的第一个元素位置，high为最后一个元素的位置，然后不断的移动两标记并交换元素
1.high 向前移动找到第一个比pivot小的元素
2.low向后移动，找到第一个比pivot大的元素
3.交换两个元素的位置，继续移动标记，直到low>high为止

```

    * 最好平均时间复杂度o(nlog2n)
    * 最好、平均空间复杂度o(log2n)
    * 最坏的时间复杂度 逆序o(n平方2)
    * 最坏空间复杂度o(n)
### 选择排序
  每一趟在后面n-i+1(i=1,2,..n-1)个带排序元素中选取关键字最小的元素，作为有序自序列的第i个元素，直到n-1趟做完，带排序元素只剩下一个
  一趟会将一个元素放在最终的位置上
   * 简单选择排序
  
```
 最常想到的排序方式,取出当前元素A[I]比较遍历数组，如果当前a[i]<a[k]则将a[i]插入到a[k]前面
```

   *
   * 堆排序
### 归并排序
### 基数排序
